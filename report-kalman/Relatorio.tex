%% Adaptado de 
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%% Traduzido para o congresso de IC da USP
%%*****************************************************************************
% Não modificar

\documentclass[twoside,conference,a4paper]{IEEEtran}

%******************************************************************************
% Não modificar
\usepackage{IEEEtsup} % Definições complementares e modificações.
\usepackage[latin1]{inputenc} % Disponibiliza acentos.
\usepackage[english,brazil]{babel}
%% Disponibiliza Inglês e Português do Brasil.
\usepackage{latexsym,amsfonts,amssymb} % Disponibiliza fontes adicionais.
\usepackage{theorem} 
\usepackage[cmex10]{amsmath} % Pacote matemático básico 
\usepackage{url} 
%\usepackage[portuges,brazil,english]{babel}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{color}
\usepackage[pagebackref=true,breaklinks=true,letterpaper=true,colorlinks,bookmarks=false]{hyperref}
\usepackage[tight,footnotesize]{subfigure} 
\usepackage[noadjust]{cite} % Disponibiliza melhorias em citações.
\usepackage{listings}
\usepackage{todonotes}
%%*****************************************************************************

\begin{document}
\selectlanguage{brazil}
\renewcommand{\IEEEkeywordsname}{Palavras-chave}

%%*****************************************************************************

\urlstyle{tt}
% Indicar o nome do autor e o curso/nível (grad-mestrado-doutorado-especial)
\title{MO810 - Trabalho Final}
\author{%
 \IEEEauthorblockN{Luísa Madeira Cardoso\,\IEEEauthorrefmark{1}}
 \IEEEauthorblockA{\IEEEauthorrefmark{1}%
                   Aluno especial - Mestrado \\
                   E-mail: lu.madeira2@gmail.com}
}

%%*****************************************************************************

\maketitle

%%*****************************************************************************
% Resumo do trabalho
\begin{abstract}
O objetivo deste trabalho é a implementação de um sistema de localização.

\end{abstract}

% Indique três palavras-chave que descrevem o trabalho
\begin{IEEEkeywords}
 V-REP Pioneer AvoidCollision WallFollow Fuzzy
\end{IEEEkeywords}

%%*****************************************************************************
% Modifique as seções de acordo com o seu projeto

\section{Introdução}

Este projeto consiste no desenvolvimento de um sistema de controle para o \textit{Pioneer P3-DX} no simulador \textit{V-REP}. A implementação foi realizada em Python 3.5, com a utilização de algumas bibliotecas como o Scikit-fuzzy e Matplotlib. Os ciclos de atualização de leitura do sensores acontecem por padrão a cada 200ms. O código fonte pode ser obtido em https://github.com/luwood/MO810-vrep-python. As instruções de instalação se encontram no README do projeto. 

Este artigo está dividido em três sessões principais, cada uma com sua apresentação e discussão dos resultados.

\begin{itemize}
 \item Localização de Landmarks
 \item Filtro de Kalman
\end{itemize}


\section{Odometria}
O cálculo da odometria foi realizado com base na estimativa de velocidade das rodas. A implementação deste componente está na classe \textit{OdometryPoseUpdater}. 

\subsection{Rodas}
Cada roda possui um \textit{encoder} que provê sua posição angular. Através da coleta temporal desta informação é possível determinar sua velocidade utilizando a seguinte fórmula:
 
\[ V = \frac{\Delta \theta}{\Delta time} R \]

Em que \( \Delta \theta \) representa a diferença angular entre posições do \textit{encoder} durante um intervalo de tempo \(\Delta time\) e \(R\) é o raio da roda. É importante destacar que o cálculo da diferença angular deve levar em conta a orientação do giro e o universo em que os ângulos estão.  

A implementação do cálculo de velocidade da roda encontra-se na classe \textit{Wheel}. A orientação do giro é obtida utilizando a hipótese que a diferença angular deve ser sempre menor do que \( \pi \). 

\subsection{Velocidade do Robô diferencial}
Dada a velocidade de cada roda, pode-se calcular a velocidade linear e angular do robô através da fórmula:

\[ V = \frac{V_r + V_l}{2}\]
\[ \omega = \frac{V_r - V_l}{D}\]

Em que \(V_r\) é a velocidade da roda direita, \(V_l\) é a roda esquerda, \(D\) é a distância entre as rodas, \(V\) é a velocidade linear e \(\omega\) é a velocidade angular. 

\subsection{Pose}
A pose do robô é então calculada 


\begin{lstlisting}[language=python]
x = lastPose.x + (deltaSpace * cos( \ 
    addDelta(lastPose.orientation, deltaTheta/2)))
y = lastPose.y + (deltaSpace * sin( \ 
    addDelta(lastPose.orientation, deltaTheta/2)))
theta = addDelta(lastPose.orientation, \
                 deltaTheta)
        
\end{lstlisting}

\subsection{Resultados}

O gráfico comparando a posição real do robô e a posição calculada através da odometria pose ser visto na figura~\ref{fig:fig0}. É possível observar que o trajeto em linha reta obtido pela odometria é preciso. Porém assim que a primeira curva é realizada a diferença entre as posições começa a divergir. A diferença torna-se maior a cada iteração devido aos erros acumulados. A tabela \ref{tab:tab1} mostra a evolução do erro no cálculo da orientação durante um determinado período de teste. 

\begin{table}[ht]
\renewcommand{\arraystretch}{1.3}
\centering
 \caption{Diferença \(\theta\) em graus - a cada 200ms}
 \label{tab:tab1}
 \begin{tabular}{lcc}\hline
Real & Odometria & Erro \\ \hline \hline
  -0.424  & -0.406    & 0.018 \\
-0.515  & -0.488    & 0.027 \\
-0.783  & -0.718    & 0.065 \\
-1.182  & -1.065    & 0.117 \\
-2.033  & -1.818    & 0.215 \\
-3.048  & -2.724    & 0.324 \\
-4.355  & -3.861    & 0.494 \\
-6.122  & -5.416    & 0.706 \\
-7.843  & -6.953    & 0.89  \\
-9.851  & -8.747    & 1.104 \\
-12.613 & -11.227   & 1.386 \\
-14.864 & -13.288   & 1.576 \\
-18.003 & -16.129   & 1.874 \\
-22.479 & -20.084   & 2.395 \\ \hline
 \end{tabular}
\end{table}

Pode-se concluir que a odometria é um método de estimativa extremamente suscetível a erros acumulados. Para tornar este método viável seria necessário necessário realizar correções no cálculo da orientação. A utilização de uma bússola, por exemplo, poderia auxiliar nesta computação. 


\begin{figure}[ht]
\centering
\includegraphics[width=1\hsize]{images/odometry.png}
\caption{Odometria: Linha vermelha, Ground Thruth: Linha azul - Exemplo com script rodando algoritmo de Braitenberg}
\label{fig:fig0}
\end{figure}

\section{Localizando Landmarks}
A ideia inicial deste projeto era permitir que a localização do robô fosse obtida a partir da comunicação com uma base. O princípio seria semelhante a tecnologia utilizada no StarGazer (HagiSonic): o robô envia um sinal e a base o reflete. Deste modo é possível determinar a distância entre os dois objetos. 
\subsection{Teoria}
Através da distância de um único ponto, é impossível determinar sua localização precisa. Considerando o sistema local de coordenadas do robô, pode-se ver na figura \ref{fig:robot-base} que a base poderia estar em qualquer ponto do círculo determinado pela distância calculada entre o sensor e a base. Portanto, são necessários mais sensores no robô para determinar a localização da base. 

Com três sensores é possível determinar a posição da base através da resolução de um sistema linear de equações. Na figura \ref{fig:robot3-base} podemos ver que o círculo que parte de cada sensor, se intersecta em um único ponto. 

As equações de cada uma das circunferências pode ser descrita da seguinte forma:
\begin{equation}
r_1^2 = (x - x_1)^2 + (y - y_1)^2 
\end{equation}
\begin{equation}
r_2^2 = (x - x_2)^2 + (y - y_2)^2 
\end{equation}
\begin{equation}
r_3^2 = (x - x_3)^2 + (y - y_3)^2 \\
\end{equation}

Para encontrar o ponto de intersecção entre as três circunferências, precisamos encontrar os valores de \(x\) e \(y\) combinando as três equações quadráticas em um sistema de duas equações lineares. 
Subtraindo (2) de (1) e (3) de (1):

\[
2x(x_2 - x_1)^2 + 2y(y_2 - y_1)^2 + (x_1^2 - x_2^2) + (y_1^2 - y_2^2) - (r_1^2 - r_2^2) = 0 \]
\[
2x(x_3 - x_1)^2 + 2y(y_3 - y_1)^2 + (x_1^2 - x_3^2) + (y_1^2 - y_3^2) - (r_1^2 - r_3^2) = 0
\]

A solução do sistema é representa a localização da base utilizando o sistema de coordenadas local do robô. 

\subsection{Transformação de coordenadas}
Para implementação do filtro de  \textbf{KALMAN - [colocar sessão]} é necessário identificar a posição da base no sistema de coordenadas globais. 
A transformação do sistema de coordenadas locais do robô para o sistema global é dado pela transformação:
\[
\begin{array}{ccc} 
1 & 0 & dx \\ 
0 & 1 & dy \\
0 & 0 & 1 
\end{array}
\]
 

\subsection{Implementação}
O robô possui três transceptores em seu topo que estão dispostos como mostrado na figura \ref{fig:robot3-base}. A base se encontra nas coordenadas \((0,0)\) do sistema global de referência. A distância entre os tranceptores e a base é calculada utilizando o módulo de cálculo de distâncias provido pelo simulador V-REP. É importante ressaltar que este cálculo de distâncias em uma simulação mais verossímil precisaria ser implementado.

A implementação do cálculo de intersecção das três circunferências é o método \textit{calculatePoint} no módulo \textit{AngleUniverse}. Ele é utilizado pela classe \textit{BaseDetector} para calcular a posição da base dadas as distâncias obtidas dos transceptores. 


\begin{figure}[ht]
\centering
\includegraphics[width=1\hsize]{images/robot-base-radius.png}
\caption{Robô com apenas um sensor de distância da base}
\label{fig:robot-base}
\end{figure}


\begin{figure}[ht]
\centering
\includegraphics[width=1\hsize]{images/robot-base-three.png}
\caption{Robô três sensores de distância da base}
\label{fig:robot3-base}
\end{figure}





\section{Filtro de Kalman}

Filtro de Kalman. \cite{thrun2005probabilistic}

\begin{figure}[ht]
\centering
\includegraphics[width=1\hsize]{images/kalman-1base.png}
\caption{EFK: using 1 landmark}
\label{fig:efk1}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=1\hsize]{images/kalman-2base.png}
\caption{EFK: using 2 landmarks}
\label{fig:efk2}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[width=1\hsize]{images/kalman-3base.png}
\caption{EFK: using 3 landmarks}
\label{fig:efk3}
\end{figure}

\section{Resultados}

Filtro de Kalman é muito bom. 


%******************************************************************************
% Referências - Definidas no arquivo Relatorio.bib
 +-------------+

\bibliographystyle{IEEEtran}

\bibliography{Relatorio}


%******************************************************************************



\end{document}
